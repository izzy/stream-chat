<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@500;800&display=swap" rel="stylesheet">

    <style>
        body,
        html,
        #chat {
            background: transparent;
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        @keyframes append-animate {
            from {
                height: 0;
                opacity: 0;
            }

            to {
                height: auto;
                opacity: 1;
            }
        }

        @keyframes chat {
            0% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        .chat-message {
            animation: append-animate .3s linear;
            transition: max-height 0.3s ease-out;
            height: auto;
            word-break: normal;
            overflow-wrap: break-word;
            hyphens: auto;
            hyphenate-character: "Â»";
        }

        .msg-badges {
            vertical-align: middle;
        }

        .msg-user::after {
            content: ": ";
        }

        .msg-pronoun {
            padding: 0rem 0.3rem;
        }

        .msg-badges>img {
            width: 1rem;
            box-shadow: 0 0 2px black;
        }

        .msg-text>img {
            vertical-align: middle;
            width: 1.4rem;
        }

        .msg-text>.announcement {
            font-weight: bold;
        }

        .msg-timestamp {
            padding: 0rem 0.2em;
            font-size: 0.8em;
        }

        .msg-user {
            font-weight: bold;

        }
    </style>

    <style type="text" id="enable-bubbles">
        #chat {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        .chat-message {
            margin: 0 5px 5px 5px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffe0f0;
            border-radius: 6px;
            color: white;
        }

        .msg-text,
        .msg-user {
            padding: 0.4rem;
            display: block;
        }

        .msg-user {
            background: #ffe0f0;
            font-weight: bold;
            color: black;
        }

        .msg-pronoun {
            right: 1em;
            position: absolute;
        }

        .msg-timestamp {
            border: 1px solid transparent;
            border-radius: 1rem;
            background-color: rgba(0, 0, 0, 0.6);
            margin-right: 0.25rem;
            vertical-align: middle;
            padding: 0.1rem 0.3rem;
            color: white;
            font-size: .6rem;
        }

        .msg-user {
            font-weight: normal;
        }

        .msg-user::after {
            content: "";
        }

        .msg-text>.announcement {
            display: block;
        }
    </style>

    <style id="enable-horizontal" type="text">
        #chat {
            display: flex;
            flex-direction: row;
            justify-content: flex-end;
            white-space: nowrap;
        }

        .chat-message {
            margin-left: 1rem;
            float: left;
        }

        .msg-user, .msg-text {
            padding: 0.4rem;
        }
    </style>

    <style id="horizontal-bubbles" type="text">
        .msg-pronoun {
            position: inherit;
        }

        .msg-user {
            text-align: right;
        }

        .msg-text>.announcement {
            display: inline;
        }
    </style>
</head>

<body>
    <div id="chat"></div>

    <script>
        function getRnd(max, min = 0) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        function searchParamIsTrue(p, d = false) {
            let v = new URLSearchParams(window.location.search).get(p);
            if (v === undefined || v === null) {
                return d;
            }

            return String(v).toLowerCase() === 'true' || String(v) === '1';
        }

        function searchParamOrDefault(p, d = null) {
            let v = new URLSearchParams(window.location.search).get(p);
            if (v === null) {
                return d;
            }
            return v;
        }

        function htmlentities(str) {
            return str.replace(/[\u00A0-\u9999<>\&]/gim, (i) => {
                return '&#' + i.charCodeAt(0) + ';';
            });
        }

        /**
         * @param {string} tag The HTML tag name
         * @param {object} attributes Attributes for the HTML tag
         * @param {string} text The innerText of the HTML tag
         * @returns {string}
         */
        function createElement(tag, attributes, text = false) {
            let element = document.createElement(tag);

            if (attributes !== undefined) {
                for (let key in attributes) {
                    element.setAttribute(key, attributes[key]);
                }
            }

            if (text !== undefined && text !== false) {
                element.innerText = text;
            }

            return element;
        }

        function parseURL() {
            let url = new URL(document.URL);

            direction = 'vertical';
            if (url.searchParams.get("direction") !== null) {
                direction = url.searchParams.get("direction").toLowerCase() === 'horizontal' ? 'horizontal' :
                    'vertical';
            }

            const get_color = (p, d = null) => {
                let u = url.searchParams.get(p);
                if (u === null) {
                    return d;
                }
                let c = {
                    r: u.slice(0, 2),
                    g: u.slice(2, 4),
                    b: u.slice(4, 6)
                };
                return c;
            }
            let colors = {
                'page_background': get_color('background'),
                'text_background': get_color('bubble_color'),
                'text': get_color('text_color'),
                'message': get_color('msg_color'),
                'default': get_color('default_color', {
                    r: 'ff',
                    g: 'e0',
                    b: 'f0'
                }),
                'pastel': searchParamIsTrue("pastel"),
            }

            let cmdprefix = null;
            if (url.searchParams.get("cmdprefix") !== null) {
                cmdprefix = url.searchParams.get("cmdprefix");
            }

            let bot_list = [];
            if (url.searchParams.get("bots") !== null) {
                bot_list = url.searchParams.get("bots").toLowerCase().split(',');
            }

            // TODO: Implement different timestamp formats
            let timestamp = false;
            let timestamp_locale = 'en-US';
            let timestamp_options = {
                hour: '2-digit',
                minute: '2-digit'
            };

            if (url.searchParams.get("timestamp") !== null) {
                timestamp = searchParamIsTrue("timestamp");
            }

            if (url.searchParams.get("timestamp_locale") !== null) {
                timestamp_locale = url.searchParams.get("timestamp_locale");
            }

            // Streamer.Bot specific configuration
            let streamerbotEnabled = true;
            let streamerbotConfig = {
                'enabled': false,
                'twitch': false,
                'youtube': false,
                'websocket': '',
            };
            if (streamerbotEnabled === searchParamIsTrue("sb_enabled")) {
                let sb_ws_uri = 'ws://localhost:8080/';
                if (url.searchParams.get("sb_ws_uri") !== null) {
                    sb_ws_uri = decodeURI(url.searchParams.get("sb_ws_uri"));
                }

                streamerbotConfig = {
                    'enabled': streamerbotEnabled,
                    'twitch': searchParamIsTrue("sb_twitch", false),
                    'youtube': searchParamIsTrue("sb_youtube", false),
                    'websocket': sb_ws_uri
                }
            }

            // Bean.Bot specific configuration
            let beanbotEnabled = true;
            let beanbotConfig = {
                'enabled': false,
                'twitch': false,
                'websocket': 'ws://localhost:6969/',
            };
            return {
                'plugins': {
                    'streamerbot': streamerbotConfig,
                    'beanbot': {
                        'enabled': searchParamIsTrue("bb_enabled"),
                    }
                },
                'ui': {
                    'direction': direction,
                    'bubbles': searchParamIsTrue("bubbles"),
                    'colors': colors,
                    'timestamp': {
                        'enabled': searchParamIsTrue("timestamp"),
                        'locale': timestamp_locale,
                        'options': timestamp_options,
                    },
                    'fade_duration': searchParamOrDefault("fade_duration", false),
                    'max_messages': searchParamOrDefault("max_messages", false),
                    'pronouns': searchParamIsTrue("pronouns", true),
                    'highlights': searchParamIsTrue("highlights", true),
                    'announcements': searchParamIsTrue("announcements", false),
                    'badges': {
                        'enabled': searchParamIsTrue("badges", true),
                        'left': searchParamIsTrue("badges_left"),
                    },
                    'emote_size': searchParamOrDefault('emote_size', '1.4rem'),
                    'font': {
                        'family': searchParamOrDefault("fontfamily", "Open Sans"),
                        'size': searchParamOrDefault("fontsize", "large")
                    },
                },
                'exclusion': {
                    'cmdprefix': cmdprefix,
                    'bots': bot_list,
                },
                'debug': searchParamIsTrue("debug"),

            }
        }

        const config = parseURL();

        console.debug(['Loaded config', config]);

        let socket, pronouns_users = {},
            pronouns;

        // Fill the pronoun cache
        // TODO: Handle errors on this
        fetch('https://pronouns.alejo.io/api/pronouns').then(response => response.json()).then(data => {
            pronouns = data;
        });

        /**
         * Get the pronoun for a user and cache it for future use
         *
         * @param {string} user The user to get the pronoun for
         * @returns {string} The pronoun for the user
         */
        async function fetch_pronoun(user) {
            if (user in pronouns_users) {
                return pronouns_users[user];
            } else {
                return fetch(`https://pronouns.alejo.io/api/users/${user}`).then(response => response.json()).then(
                    data => {
                        pronouns_users[user] = data[0];
                        return data;
                    }).catch(() => {
                    return '';
                });
            }

        }

        /**
         * Get the pronoun for a user.
         * This is a wrapper for fetch_pronoun() that returns either the pronoun or false when pronouns are disabled,
         * when pronouns for the user aren't set or the API is unavailable.
         *
         * @param {string} user The user to get the pronoun for
         * @returns {string|bool} The pronoun for the user
         */
        function get_pronoun(user) {
            if (config['ui']['pronouns'] === true && (user in pronouns_users && pronouns_users[user] !== undefined)) {
                return pronouns.filter(p => p.name === pronouns_users[user]['pronoun_id'])[0].display;
            } else {
                return false;
            }
        }

        /**
         * Get the text colour for a user.
         * TODO: change color to RGB object
         *
         * @param {Color} color The user's text color
         * @returns {string} The calculated color according to settings
         */
        function get_text_color(color) {
            // TODO pastel mode for text color
            if (config['ui']['colors']['text']) {
                return config['ui']['colors']['text'];
            }

            let color_r = parseInt((color.r), 16);
            let color_g = parseInt((color.g), 16);
            let color_b = parseInt((color.b), 16);

            let brightness = Math.round(((parseInt(color_r) * 299) +
                (parseInt(color_g) * 587) +
                (parseInt(color_b) * 114)) / 1000);

            if (brightness < 125) {
                return {
                    r: 'FF',
                    g: 'FF',
                    b: 'FF'
                };
            } else {
                return {
                    r: '00',
                    g: '00',
                    b: '00'
                };
            }
        }

        /**
         * Get the background color for a user.
         * @param {Color} color An RGB tuple of the user's text color
         * @param {string} override_source Config attribute to take for overrides
         * @returns {Color} The background color for the user
         */
        function get_user_color(color, override_source = "text_background") {
            // TODO pastel mode for background color
            if (config['ui']['colors'][override_source]) {
                return config['ui']['colors'][override_source];
            }

            if (color === null || color === undefined) {
                return config['ui']['colors']['default'];
            } else {
                return color;
            }
        }

        /**
         * Returns a normalized version of the given color as RGB struct.
         * @param {string} color A string containing a color in hexadecimal RGB notation
         * @returns {Color} The normalized color tuple
         */
        function get_color(color) {
            if (color === null || color === undefined) {
                return config['ui']['colors']['default'];
            } else {
                color = color.replace('#', '');
                return {
                    r: color.slice(0, 2),
                    g: color.slice(2, 4),
                    b: color.slice(4, 6)
                };
            }
        }

        /**
         * Returns a hex code from an RGB color struct.
         * @param {Color} color An RGB color struct
         * @returns {string} A hex color code
         */
        function get_color_hex(color) {
            if (color === 'transparent') {
                return 'transparent';
            } else if (color === null || color === undefined) {
                return get_color_hex(config['ui']['colors']['default']);
            } else {
                return `#${color.r}${color.g}${color.b}`;
            }
        }

        let add_message = (id, message, author, color, timestamp, badges = [], highlight = false) => {
            let background_color = get_user_color(color);
            let text_color = get_text_color(background_color);

            let el_badges = createElement('span', {
                'class': 'msg-badges'
            });
            let el_pronoun = createElement('span', {
                'class': 'msg-pronoun'
            }, author['pronoun']);
            let el_message = createElement('span', {
                'class': 'msg-text'
            });

            if (config['ui']['colors']["message"]) {
                el_message.style.color = get_color_hex(config['ui']['colors']["message"]);
            }

            let message_style = '';
            if (highlight === true && config['ui']['highlights'] === true) {
                message_style =
                    `background-color: ${get_color_hex(background_color)}; color: ${get_color_hex(text_color)};`;
            }

            let div_message = createElement('div', {
                'id': id,
                'data-user-id': author['id'],
                'class': 'chat-message',
                'style': `border-color: ${get_color_hex(background_color)}; ${message_style}`
            });

            if (config['ui']['fade_duration'] !== null) {
                fade_duration = config['ui']['fade_duration'];
                let tmp_style = div_message.getAttribute("style");
                let fade_style = "transition: max-height 0.3s ease-out; animation: chat 1s ease " + fade_duration +
                    "s 1 normal forwards; margin-left: 0.5rem; float: left;";
                div_message.setAttribute("style", tmp_style + fade_style);
            }

            // If we don't use bubbles, we don't use the user colour as background
            if (config['ui']['bubbles'] === false) {
                text_color = get_user_color(color, "text_color");
                background_color = "transparent";
            }

            let el_user = createElement('span', {
                'class': 'msg-user',
                'style': `color: ${get_color_hex(text_color)}; background-color: ${get_color_hex(background_color)}`
            }, author.name);

            if (config['ui']['badges']['enabled'] === true && badges.length > 0) {
                for (let badge of badges) {
                    let el_badge = createElement('img', {
                        'src': badge["url"],
                    });
                    el_badges.appendChild(el_badge);
                }
            }

            el_message.innerHTML = message;

            // Adds badges and pronouns to the user line
            if (config['ui']['badges']['left'] === false) {
                el_user.appendChild(el_badges);
            } else {
                el_user.prepend(el_badges);
            }

            // add timestamp
            if (config['ui']['timestamp']['enabled'] === true) {
                var date = new Date();
                let el_timestamp = createElement('span', {
                        'class': 'msg-timestamp'
                    },
                    date.toLocaleTimeString(config['ui']['timestamp']['locale'], config['ui']['timestamp'][
                        'options'
                    ]));
                if (config['ui']['bubbles'] === false) {
                    div_message.appendChild(el_timestamp);
                } else {
                    el_user.prepend(el_timestamp);
                }
            }

            if (author['pronoun']) {
                el_user.appendChild(el_pronoun);
            }

            // Adds the user line and message to the message div
            div_message.appendChild(el_user);
            div_message.appendChild(el_message);

            document.getElementById('chat').appendChild(div_message);

            const element = document.getElementById('chat');
            element.scrollTop = element.scrollHeight;
        }

        let StreamerBot = {
            'message': {
                'twitch': async (msg_id, user_id, author, author_color, message, emotes = [], role = 0,
                    badges = [], highlight = false, announcement = false, pronoun = false) => {
                    // TODO handle cheermotes

                    if (skip_message(message, author)) {
                        return;
                    }

                    if (pronoun === false) {
                        await fetch_pronoun(author);
                        pronoun = get_pronoun(author);
                    }

                    author = {
                        name: author,
                        id: user_id,
                        pronoun: pronoun === false ? false : `(${pronoun})`,
                    }

                    // XSS protection for the message
                    message = htmlentities(message);

                    for (const emote in emotes) {
                        let el_emote = document.createElement('img');
                        el_emote.src = emotes[emote].imageUrl;
                        if (parseInt(config['ui']['emote_size']) > 0) {
                            el_emote.style = `height: ${config['ui']['emote_size']}rem; width: auto;`;
                        }

                        message = message.replace(emotes[emote].name, el_emote.outerHTML);
                    }

                    if (badges.length > 0) {
                        badges = badges.map(badge => {
                            return {
                                url: badge["imageUrl"]
                            };
                        });
                    }

                    if (announcement === true) {
                        message = '<span class="announcement">ðŸ“¢ Announcement: </span>' + message;
                    }

                    let color = get_color(author_color);
                    add_message(msg_id, message, author, color, 0, badges, highlight);
                },
                'youtube': (message_id, user_id, user_name, message, timestamp, owner, moderator, sponsor,
                    verified) => {
                    // TODO: Add message
                    // TODO: Add youtube logo as badge
                    // TODO: Add badges for owner, moderator, sponsor, verified

                    let author = {
                        name: user_name,
                        id: user_id,
                        pronoun: false,
                    }

                    let color = get_user_color({
                        r: 'FF',
                        g: '00',
                        b: '00'
                    });
                    let badges = [{
                        'url': 'https://yt3.ggpht.com/m6yqTzfmHlsoKKEZRSZCkqf6cGSeHtStY4rIeeXLAk4N9GY_yw3dizdZoxTrjLhlY4r_rkz3GA=w24-h24-c-k-nd'
                    }];
                    message = htmlentities(message);

                    const yt_emote_width = '28';
                    const yt_emote_height = '28';

                    if (parseInt(config['ui']['emote_size']) > 0) {
                        const yt_emote_width = config['ui']['emote_size'];
                        const yt_emote_height = config['ui']['emote_size'];
                    }

                    const yt_emotes = {
                        ':yt:': `https://yt3.ggpht.com/m6yqTzfmHlsoKKEZRSZCkqf6cGSeHtStY4rIeeXLAk4N9GY_yw3dizdZoxTrjLhlY4r_rkz3GA=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':oops:': `https://yt3.ggpht.com/qByNS7xmuQXsb_5hxW2ggxwQZRN8-biWVnnKuL5FK1zudxIeim48zRVPk6DRq_HgaeKltHhm=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':buffering:': `https://yt3.ggpht.com/foWgzjN0ggMAA0CzDPfPZGyuGwv_7D7Nf6FGLAiomW5RRXj0Fs2lDqs2U6L52Z4J2Zb-D5tCUAA=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':stayhome:': `https://yt3.ggpht.com/u3QDxda8o4jrk_b01YtJYKb57l8Zw8ks8mCwGkiZ5hC5cQP_iszbsggxIWquZhuLRBzl5IEM2w=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':dothefive:': `https://yt3.ggpht.com/ktU04FFgK_a6yaXCS1US-ReFkLjD22XllcIMOyBRHuYKLsrxpVxsauV1gSC2RPraMJWXpWcY=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':elbowbump:': `https://yt3.ggpht.com/gt39CIfizoIAce9a8IzjfrADV5CjTbSyFKUlLMXzYILxJRjwAgYQQJ9PXXxnRvrnTec7ZpfHN4k=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':goodvibes:': `https://yt3.ggpht.com/6LPOiCw9bYr3ZXe8AhUoIMpDe_0BglC4mBmi-uC4kLDqDIuPu4J3ErgV0lEhgzXiBluq-I8j=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':thanksdoc:': `https://yt3.ggpht.com/Av7Vf8FxIp0_dQg4cJrPcGmmL7v9RXraOXMp0ZBDN693ewoMTHbbS7D7V3GXpbtZPSNcRLHTQw=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':videocall:': `https://yt3.ggpht.com/bP-4yir3xZBWh-NKO4eGJJglr8m4dRnHrAKAXikaOJ0E5YFNkJ6IyAz3YhHMyukQ1kJNgQAo=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':virtualhug:': `https://yt3.ggpht.com/-o0Di2mE5oaqf_lb_RI3igd0fptmldMWF9kyQpqKWkdAd7M4cT5ZKzDwlmSSXdcBp3zVLJ41yg=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':yougotthis:': `https://yt3.ggpht.com/WxLUGtJzyLd4dcGaWnmcQnw9lTu9BW3_pEuCp6kcM2pxF5p5J28PvcYIXWh6uCm78LxGJVGn9g=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':sanitizer:': `https://yt3.ggpht.com/4PaPj_5jR1lkidYakZ4EkxVqNr0Eqp4g0xvlYt_gZqjTtVeyHBszqf57nB9s6uLh7d2QtEhEWEc=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':takeout:': `https://yt3.ggpht.com/ehUiXdRyvel0hba-BopQoDWTvM9ogZcMPaaAeR6IA9wkocdG21aFVN_IylxRGHtl2mE6L9jg1Do=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':hydrate:': `https://yt3.ggpht.com/Plqt3RM7NBy-R_eA90cIjzMEzo8guwE0KqJ9QBeCkPEWO7FvUqKU_Vq03Lmv9XxMrG6A3Ouwpg=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':chillwcat:': `https://yt3.ggpht.com/ZN5h05TnuFQmbzgGvIfk3bgrV-_Wp8bAbecOqw92s2isI6GLHbYjTyZjcqf0rKQ5t4jBtlumzw=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':chillwdog:': `https://yt3.ggpht.com/jiaOCnfLX0rqed1sISxULaO7T-ktq2GEPizX9snaxvMLxQOMmWXMmAVGyIbYeFS2IvrMpxvFcQ=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':elbowcough:': `https://yt3.ggpht.com/kWObU3wBMdHS43q6-ib2KJ-iC5tWqe7QcEITaNApbXEZfrik9E57_ve_BEPHO86z4Xrv8ikMdW0=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':learning:': `https://yt3.ggpht.com/LiS1vw8KUXmczimKGfA-toRYXOcV1o-9aGSNRF0dGLk15Da2KTAsU-DXkIao-S7-kCkSnJwt=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':washhands:': `https://yt3.ggpht.com/66Fn-0wiOmLDkoKk4FSa9vD0yymtWEulbbQK2x-kTBswQ2auer_2ftvmrJGyMMoqEGNjJtipBA=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':socialdist': `https://yt3.ggpht.com/0WD780vTqUcS0pFq423D8WRuA_T8NKdTbRztChITI9jgOqOxD2r6dthbu86P6fIggDR6omAPfnQ=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                        ':shelterin:': `https://yt3.ggpht.com/KgaktgJ3tmEFB-gMtjUcuHd6UKq50b-S3PbHEOSUbJG7UddPoJSmrIzysXA77jJp5oRNLWG84Q=w${yt_emote_width}-h${yt_emote_height}-c-k-nd`,
                    };

                    for (const e in yt_emotes) {
                        let el_emote = document.createElement('img');
                        el_emote.src = yt_emotes[e];
                        el_emote.style = `height: ${yt_emote_height}px; width: ${yt_emote_width}px;`;

                        message = message.replaceAll(e, el_emote.outerHTML);
                    }

                    add_message(message_id, message, author, color, timestamp, badges, false);
                }
            },
        }

        let BeanBot = {
            'message': {
                'twitch': (message) => {
                    console.log(message);
                }
            }
        }

        /**
         * Checks if a message should be skipped.
         * @param {string} message The message to check
         * @param {string} user The user name to check
         * @returns {boolean} True if the message should be skipped, false otherwise
         */
        function skip_message(message, user) {
            if ((config['exclusion']['cmdprefix'] !== false && message.startsWith(config['exclusion']['cmdprefix'])) ||
                (config['exclusion']['bots'].includes(user.toLowerCase()))) {
                return true;
            } else {
                return false;
            }
        }

        function remove_old_messages() {
            let chat = document.getElementById('chat');
            let messages = chat.getElementsByClassName('chat-message');
            let messages_to_remove = [];

            // Remove old messages when there are more than the max_messages setting
            if (config['ui']['max_messages'] !== false) {
                let max_messages = config['ui']['max_messages'];
                if (messages.length > max_messages) {
                    for (let i = 0; i < messages.length - max_messages; i++) {
                        messages_to_remove.push(messages[i]);
                    }
                }
            }

            for (let i = 0; i < messages.length; i++) {

                // Remove messages that are outside the bounding box
                // bottom when vertical scrolling is enabled,
                // right when horizontal scrolling is enabled
                if ((config['ui']['direction'] === 'vertical' && messages[i].getBoundingClientRect().bottom < 0) ||
                    (config['ui']['direction'] === 'horizontal' && messages[i].getBoundingClientRect().right < 0)
                ) {
                    messages_to_remove.push(messages[i]);
                }

                // Remove messages that are older than the max age (fade_duration)
                else if (parseInt(config['ui']['fade_duration']) > 0 && window.getComputedStyle(messages[i]).opacity ===
                    "0") {
                    messages_to_remove.push(messages[i]);
                }
            }

            for (let message of messages_to_remove) {
                chat.removeChild(message);
            }
        }

        function remove_messages_by_user_id(user_id) {
            console.debug('Removing messages by user id: ' + user_id);

            let chat = document.getElementById('chat');
            let messages = chat.getElementsByClassName('chat-message');
            let messages_to_remove = [];

            for (let i = 0; i < messages.length; i++) {
                if (parseInt(messages[i].dataset.userId) === user_id) {
                    messages_to_remove.push(messages[i]);
                }
            }

            for (let message of messages_to_remove) {
                chat.removeChild(message);
            }
        }

        function remove_messages_by_message_id(message_id) {
            console.debug('Removing messages by message id: ' + message_id);

            let chat = document.getElementById('chat');
            let messages = chat.getElementsByClassName('chat-message');
            let messages_to_remove = [];

            for (let i = 0; i < messages.length; i++) {
                if (messages[i].id === message_id) {
                    messages_to_remove.push(messages[i]);
                }
            }

            for (let message of messages_to_remove) {
                chat.removeChild(message);
            }
        }

        function initializeTheme() {
            // Set up the UI
            if (config['ui']['bubbles'] === true) {
                document.getElementById('enable-bubbles').removeAttribute('type');
            }

            if (config['ui']['direction'] === 'horizontal') {
                document.getElementById('enable-horizontal').removeAttribute('type');
            }

            if (config['ui']['bubbles'] === true && config['ui']['direction'] === 'horizontal') {
                document.getElementById('horizontal-bubbles').removeAttribute('type');
            }

            if (config['ui']['colors']['page_background'] !== null) {
                document.body.style.background = get_color_hex(config['ui']['colors']['page_background']);
            } else {
                document.body.style.background = "transparent";
            }

            document.getElementById("chat").style.fontFamily = config['ui']['font']['family'];
            document.getElementById("chat").style.fontSize = config['ui']['font']['size'];

        }

        function initializeConnections() {
            // Streamer.Bot websocket connection
            if (config['plugins']['streamerbot']['enabled'] === true) {
                console.debug('Streamer.Bot is enabled');

                socket = new WebSocket(config['plugins']['streamerbot']['websocket']);

                socket.onopen = () => {
                    subscribeEvents = {}

                    if (config['plugins']['streamerbot']['twitch'] === true) {
                        subscribeEvents['Twitch'] = [
                            "ChatMessage",
                            "FirstWord",
                            "Announcement",
                            "UserTimedOut",
                            "UserBanned",
                            "ChatMessageDeleted"
                        ];
                    }

                    if (config['plugins']['streamerbot']['youtube'] === true) {
                        // it's "youTube", not "YouTube"
                        // that's just what it's called in Streamer.Bot ðŸ¤·ðŸ¼â€â™€ï¸
                        subscribeEvents['YouTube'] = [
                            "Message",
                            "MessageDeleted",
                            "UserBanned",
                            "SuperChat"
                        ];
                    }

                    if (Object.keys(subscribeEvents).length > 0) {
                        let s = {
                            "request": "Subscribe",
                            "id": "obs-chat",
                            "events": subscribeEvents
                        };
                        
                        socket.send(JSON.stringify(s));
                    } else {
                        console.debug('Streamer.Bot does not have any events to subscribe to');
                    }

                    console.debug(['Connected to Streamer.Bot socket:', socket]);
                };

                socket.onclose = function () {
                    console.warn('Disconnected from Streamer.Bot socket.');
                    setTimeout(initializeConnections, 10000);
                };

                socket.onmessage = async (event) => {
                    const wsdata = JSON.parse(event.data);

                    console.debug(['Event', wsdata]);

                    if (wsdata.id === 'obs-chat') {
                        console.debug([`SUBSCRIBE: ${wsdata.status}`, wsdata]);
                    } else if (wsdata.event) {
                        if (wsdata.event.source === 'Twitch') {
                            if (wsdata.event.type === 'ChatMessage') {
                                let m = wsdata.data.message;

                                StreamerBot['message']['twitch'](m.msgId, m.userId, m.displayName, m.color, m
                                    .message, m.emotes, m.role, m.badges, m.isHighlighted, false);

                            } else if (wsdata.event.type === 'Announcement') {
                                if (config["ui"]["announcements"] === false) {
                                    return;
                                }

                                let m = wsdata.data;

                                let color = '';
                                switch (m.announcementColor.toLowerCase()) {
                                    case 'blue':
                                        color = '#0099ff';
                                        break;
                                    case 'green':
                                        color = '#00ff00';
                                        break;
                                    case 'orange':
                                        color = '#ff9900';
                                        break;
                                    case 'purple':
                                        color = '#9900ff';
                                        break;
                                    default:
                                        color = m.color;
                                        break;
                                }

                                StreamerBot['message']['twitch'](m.msgId, m.userId, m.displayName, color, m
                                    .message, m.emotes, m.role, m.badges, true, true);

                            } else if (wsdata.event.type === 'UserTimedOut' || wsdata.event.type ===
                                'UserBanned') {
                                console.debug(['User timed out or banned', wsdata]);
                                remove_messages_by_user_id(wsdata.data.userId);
                            } else if (wsdata.event.type === 'ChatMessageDeleted') {
                                console.debug(['Message deleted', wsdata]);
                                remove_messages_by_message_id(wsdata.data.targetMessageId);
                            } else {
                                console.warn(['Twitch Event not implemented', event]);
                            }
                        } else if (wsdata.event.source === 'YouTube') {
                            if (wsdata.event.type === 'Message') {
                                let m = wsdata.data;

                                if (skip_message(m.message, m.user['name'])) {
                                    return;
                                }

                                StreamerBot['message']['youtube'](m.eventId, m.user.id, m.user.name, m.message,
                                    m.user.isOwner, m.user.isModerator, m.user.isSponsor, m.user.isVerified);
                            } else if (wsdata.event.type === 'MessageDeleted') {
                                // This doesn't seem to be implemented in Streamer.Bot
                                console.debug(['Message deleted', wsdata]);
                                remove_messages_by_message_id(wsdata.data.eventId);
                            } else if (wsdata.event.type === 'UserBanned') {
                                console.debug(['User banned', wsdata]);
                                remove_messages_by_user_id(wsdata.data.user.id);
                            } else {
                                console.warn(['YouTube Event not implemented', event]);
                            }

                            remove_old_messages();
                        }
                    } else {
                        console.warn(['Event source not implemented', event]);
                    }
                }
            }

            if (config['plugins']['beanbot']['enabled'] === true) {
                console.debug('Beanbot is enabled');
            }
        };

        initializeTheme();
        if (config["debug"] === true) {
            // Debugging is used in the Overlay generator live preview
            const messages = [
                "Are you a robot?",
                "How are you?",
                "Happy birthday!",
            ];

            const badges = [
                [{
                        "name": "vip",
                        "version": "1",
                        "imageUrl": "https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/3"
                    },
                    {
                        "name": "subscriber",
                        "version": "0",
                        "imageUrl": "https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/3"
                    }
                ],
                [{
                    "name": "premium",
                    "version": "1",
                    "imageUrl": "https://static-cdn.jtvnw.net/badges/v1/bbbe0db0-a598-423e-86d0-f9fb98ca1933/3"
                }],
                [{
                        "name": "broadcaster",
                        "version": "1",
                        "imageUrl": "https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/3"
                    },
                    {
                        "name": "subscriber",
                        "version": "0",
                        "imageUrl": "https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/3"
                    },
                    {
                        "name": "glhf-pledge",
                        "version": "1",
                        "imageUrl": "https://static-cdn.jtvnw.net/badges/v1/3158e758-3cb4-43c5-94b3-7639810451c5/3"
                    }
                ]
            ]
            const emotes = [{
                    id: "555555597",
                    type: "Twitch",
                    name: ";p",
                    startIndex: 3,
                    endIndex: 4,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555597/default/dark/2.0",
                },
                {
                    id: "555555593",
                    type: "Twitch",
                    name: ":p",
                    startIndex: 6,
                    endIndex: 7,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555593/default/dark/2.0",
                },
                {
                    id: "555555562",
                    type: "Twitch",
                    name: ">(",
                    startIndex: 12,
                    endIndex: 13,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555562/default/dark/2.0",
                },
                {
                    id: "555555563",
                    type: "Twitch",
                    name: ":|",
                    startIndex: 15,
                    endIndex: 16,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555563/default/dark/2.0",
                },
                {
                    id: "6",
                    type: "Twitch",
                    name: "O_o",
                    startIndex: 18,
                    endIndex: 20,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/6/default/dark/2.0",
                },
                {
                    id: "555555557",
                    type: "Twitch",
                    name: ":-)",
                    startIndex: 33,
                    endIndex: 35,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555557/default/dark/2.0",
                },
                {
                    id: "555555599",
                    type: "Twitch",
                    name: "R)",
                    startIndex: 0,
                    endIndex: 1,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555599/default/dark/2.0",
                },
                {
                    id: "555555589",
                    type: "Twitch",
                    name: ";)",
                    startIndex: 9,
                    endIndex: 10,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555589/default/dark/2.0",
                },
                {
                    id: "555555578",
                    type: "Twitch",
                    name: "B-)",
                    startIndex: 22,
                    endIndex: 24,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555578/default/dark/2.0",
                },
                {
                    id: "555555580",
                    type: "Twitch",
                    name: ":O",
                    startIndex: 26,
                    endIndex: 27,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555580/default/dark/2.0",
                },
                {
                    id: "555555559",
                    type: "Twitch",
                    name: ":-(",
                    startIndex: 29,
                    endIndex: 31,
                    imageUrl: "https://static-cdn.jtvnw.net/emoticons/v2/555555559/default/dark/2.0",
                },
            ];

            const names = [
                "Taylor Garcia",
                "Ellen Schwartz",
                "Rebecca Mcintosh",
                "Journey Robles",
                "Rhett Acosta",
                "Logan Burnett",
                "Rigoberto Robertson",
                "Keshawn Miles",
                "Cyrus Ball",
                "Janet Braun",
                "Hadassah Bennett",
                "Joanna Cole",
            ];

            const colors = [{
                    r: "B0",
                    g: "BF",
                    b: "1A"
                },
                {
                    r: "00",
                    g: "48",
                    b: "BA"
                },
                {
                    r: "7C",
                    g: "B9",
                    b: "E8"
                },
                {
                    r: "C0",
                    g: "E8",
                    b: "D5"
                },
                {
                    r: "B2",
                    g: "84",
                    b: "BE"
                },
                {
                    r: "72",
                    g: "A0",
                    b: "C1"
                },
                {
                    r: "DB",
                    g: "2D",
                    b: "43"
                },
                {
                    r: "ED",
                    g: "EA",
                    b: "E0"
                },
                {
                    r: "C4",
                    g: "62",
                    b: "10"
                },
                {
                    r: "F0",
                    g: "F8",
                    b: "FF"
                },
                {
                    r: "EF",
                    g: "DE",
                    b: "CD"
                },
                {
                    r: "9F",
                    g: "2B",
                    b: "68"
                },
                {
                    r: "E5",
                    g: "2B",
                    b: "50"
                },
                {
                    r: "AB",
                    g: "27",
                    b: "4F"
                },
                {
                    r: "F1",
                    g: "9C",
                    b: "BB"
                },
                {
                    r: "3B",
                    g: "7A",
                    b: "57"
                },
                {
                    r: "D3",
                    g: "21",
                    b: "2D"
                },
                null,
            ];

            setInterval(() => {
                let pronoun = "";
                if (pronouns) {
                    const rnd = getRnd(pronouns.length - 1);
                    pronoun = pronouns[rnd].display;
                }
                let messagesEmote;
                let username = names[getRnd(names.length - 1)];
                const message = (() => {
                    let message = messages[getRnd(messages.length - 1)];
                    if (!!getRnd(1)) {
                        messagesEmote = Array(getRnd(10)).fill(undefined).map(() => {
                            return emotes[getRnd(emotes.length - 1)];
                        });
                        messagesEmote.forEach(({
                            name
                        }) => {
                            message = `${message} ${name}`;
                        });
                    }
                    return message;
                })();

                if (skip_message(message, username) === true) {
                    return;
                }

                if (Math.random() < 0.5 &&
                    config["plugins"]["streamerbot"]["enabled"] === true &&
                    config["plugins"]["streamerbot"]["twitch"] === true) {
                    StreamerBot["message"]["twitch"](
                        String(Math.random()),
                        Math.floor(Math.random() * 10000000),
                        username,
                        get_color_hex(colors[getRnd(colors.length - 1)]),
                        message,
                        messagesEmote,
                        getRnd(4, 0),
                        badges[getRnd(badges.length - 1)],
                        !!getRnd(1),
                        !!getRnd(1),
                        pronoun
                    );
                } else if (config["plugins"]["streamerbot"]["enabled"] === true && config["plugins"]["streamerbot"]["youtube"] === true)  {
                    StreamerBot["message"]["youtube"](String(Math.random()), Math.floor(Math.random() *
                        10000000), username, message, 0, false, false, false, false);
                }

                remove_old_messages();
            }, 2000);
        } else {
            initializeConnections();
        }
    </script>
</body>

</html>